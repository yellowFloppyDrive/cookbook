################################################################################
webgl.txt
################################################################################

--------------------------------------------------------------------------------
Graphics pipeline
--------------------------------------------------------------------------------

- Create vertex data (vertex, colors, textures, normals, etc) in native language
- Use the WebGL API to setup GPU state and to buffer the data
- Vertex shader is used to transform (translate, rotate, scale) positions
- Primitive assembly is used to generate geometry (points, lines, triangles) based on the mode
- Rasterization converts primitives to fragments by finding which pixels occupy the fragment
- Fragment shader calculates the fragment colors
- Fragment operations does depth, stencil and scissor testing
- Frame buffer contains the output image

--------------------------------------------------------------------------------
Bootstrap WebGL app
--------------------------------------------------------------------------------

function app() {
  const canvas = document.createElement("canvas");
  canvas.width = 512;
  canvas.height = 512;

  document.body.appendChild(canvas);

  const gl = canvas.getContext("webgl2");

  if (!gl) {
    throw "WebGL 2.0 is not supported";
  }
}

--------------------------------------------------------------------------------
Vertices
--------------------------------------------------------------------------------

- Winding order
    This is the order in which triangle vertices are ordered.
    The winding order determines the triangle facing direction.
    WebGL requires CCW (counter clockwise) winding order.

--------------------------------------------------------------------------------
Math
--------------------------------------------------------------------------------

type Vector3 = [number, number, number];

// Column major
type Matrix4x4 = [
  number, number, number, number,
  number, number, number, number,
  number, number, number, number,
  number, number, number, number
];

function rotationX(angle: number): Matrix4x4 {
  const cos: number = Math.cos(angle);
  const sin: number = Math.sin(angle);

  return [
    1.0,  0.0, 0.0, 0.0,
    0.0,  cos, sin, 0.0,
    0.0, -sin, cos, 0.0,
    0.0,  0.0, 0.0, 1.0
  ];
}

function rotationY(angle: number): Matrix4x4 {
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  return [
    cos, 0.0, -sin, 0.0,
    0.0, 1.0,  0.0, 0.0,
    sin, 0.0,  cos, 0.0,
    0.0, 0.0,  0.0, 1.0
  ];
}

function rotationZ(angle: number): Matrix4x4 {
  const cos: number = Math.cos(angle);
  const sin: number = Math.sin(angle);
  return [
    cos, sin, 0.0, 0.0,
   -sin, cos, 0.0, 0.0,
    0.0, 0.0, 1.0, 0.0,
    0.0, 0.0, 0.0, 1.0
  ];
}

function multiplyMatrix4x4Vector3(m: Matrix4x4, v: Vector3): Vector3 {
  return [
    m[0]*v[0] + m[4]*v[1] + m[ 8]*v[2] + m[12],
    m[1]*v[0] + m[5]*v[1] + m[ 9]*v[2] + m[13],
    m[2]*v[0] + m[6]*v[1] + m[10]*v[2] + m[14]
  ];
}

function multiplyMatrix4x4Matrix4x4(a: Matrix4x4, b: Matrix4x4): Matrix4x4 {
  return [
    a[0]*b[0] + a[4]*b[1] + a[ 8]*b[2] + a[12]*b[3],
    a[1]*b[0] + a[5]*b[1] + a[ 9]*b[2] + a[13]*b[3],
    a[2]*b[0] + a[6]*b[1] + a[10]*b[2] + a[14]*b[3],
    a[3]*b[0] + a[7]*b[1] + a[11]*b[2] + a[15]*b[3],

    a[0]*b[4] + a[4]*b[5] + a[ 8]*b[6] + a[12]*b[7],
    a[1]*b[4] + a[5]*b[5] + a[ 9]*b[6] + a[13]*b[7],
    a[2]*b[4] + a[6]*b[5] + a[10]*b[6] + a[14]*b[7],
    a[3]*b[4] + a[7]*b[5] + a[11]*b[6] + a[15]*b[7],

    a[0]*b[8] + a[4]*b[9] + a[ 8]*b[10] + a[12]*b[11],
    a[1]*b[8] + a[5]*b[9] + a[ 9]*b[10] + a[13]*b[11],
    a[2]*b[8] + a[6]*b[9] + a[10]*b[10] + a[14]*b[11],
    a[3]*b[8] + a[7]*b[9] + a[11]*b[10] + a[15]*b[11],

    a[0]*b[12] + a[4]*b[13] + a[ 8]*b[14] + a[12]*b[15],
    a[1]*b[12] + a[5]*b[13] + a[ 9]*b[14] + a[13]*b[15],
    a[2]*b[12] + a[6]*b[13] + a[10]*b[14] + a[14]*b[15],
    a[3]*b[12] + a[7]*b[13] + a[11]*b[14] + a[15]*b[15]
  ];
}

--------------------------------------------------------------------------------
OBJ file format
--------------------------------------------------------------------------------

OBJ saves 3D models in the following format
Vertex - v x y z
Normal - vn x y z
Texture coordinates - vt x y
Face - f vi/vni/vti vi/vni/vti vi/vni/vti
Comments - # Comment

Single triangle example OBJ content:
  # A simple 3D triangle

  # List of vertex coordinates
  v 0.000000 0.000000 0.000000
  v 1.000000 0.000000 0.000000
  v 0.000000 1.000000 0.000000

  # List of texture coordinates
  vt 0.000000 0.000000
  vt 1.000000 0.000000
  vt 0.000000 1.000000

  # List of vertex normals
  vn 0.000000 0.000000 1.000000

  # Face definitions (using vertices, texture coordinates, and normals)
  f 1/1/1 2/2/1 3/3/1

--------------------------------------------------------------------------------
Copy data from RAM into VRAM - Data Buffers
--------------------------------------------------------------------------------

// Define data
const vertices = [0.0, 0.0];

// Pointer to a block of VRAM
const vertexBuffer = gl.createBuffer();

// Set the ARRAY_BUFFER to point to where vertexBuffer points to
gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);

// Copy data from RAM to VRAM
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

--------------------------------------------------------------------------------
Shader programs
--------------------------------------------------------------------------------

/*
 * Vertex shader
 */

const vertexShaderSource = `
  attribute vec2 a_position;

  void main() {
    gl_Position = vec4(a_position, 0.0, 1.0);
    gl_PointSize = 10.0;
  }
`;

const vertexShader = gl.createShader(gl.VERTEX_SHADER);

if (!vertexShader) {
  throw "Could not create vertex shader!";
}

gl.shaderSource(vertexShader, vertexShaderSource);
gl.compileShader(vertexShader);

/*
 * Fragment shader
 */

const fragmentShaderSource = `
  precision mediump float;

  void main() {
    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
  }
`;

const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);

if (!fragmentShader) {
  throw "Could not create fragment shader!";
}

gl.shaderSource(fragmentShader, fragmentShaderSource);
gl.compileShader(fragmentShader);

/*
 * The pipeline program
 */

const program = gl.createProgram();

if (!program) {
  throw "Could not create the program!";
}

gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);

gl.linkProgram(program);

gl.useProgram(program);

/*
 * Program attribute definition
 */

const a_position = gl.getAttribLocation(program, "a_position");
gl.enableVertexAttribArray(a_position);
gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);

// a_position is a defined as
//   A vertex of 2 components.
//   Component type is FLOAT.
//   Vertex normalization is false.
//   0 stride / 0 skipped elements between 2 vertices.
//   0 offset from the start.


/*
 * Showing shader compilation errors
 */

const status = gl.getShaderStatus(vertexShader, gl.COMPILE_STATUS);

if (!status) {
  const log = gl.getShaderInfoLog(vertexShader);
  console.error(log);
}

--------------------------------------------------------------------------------
Render - Draw call
--------------------------------------------------------------------------------

gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
gl.drawArrays(gl.POINTS, 0, 1);

gl.bindBuffer(gl.ELEMENT_BUFFER, elementBuffer);
gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_BYTE, 0);

--------------------------------------------------------------------------------
Graphics pseudocode
--------------------------------------------------------------------------------

- Configure a canvas
- Get the webgl2 context from the canvas
- Create a vertex buffer with one vertex
- Create and compile a vertex shader with a_position and gl_PointSize to increase the size of the point
- Create and compile a fragment shader that renders everything red
- Create, link and use a program with the vertex and fragment shader
- Set the clear color to black
- Clear the color buffer bit

--------------------------------------------------------------------------------
Render a point
--------------------------------------------------------------------------------

const canvas = document.createElement("canvas");
canvas.width = 512;
canvas.height = 512;

document.body.appendChild(canvas);

const gl = canvas.getContext("webgl2");

if (!gl) {
  throw "WebGL2 is not supported!";
}

const vertices = [0.0, 0.0];
const vertexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

const vertexShaderSource = `
  attribute vec2 a_position;

  void main() {
    gl_Position = vec4(a_position, 0.0, 1.0);
    gl_PointSize = 10.0;
  }
`;

const vertexShader = gl.createShader(gl.VERTEX_SHADER);

if (!vertexShader) {
  throw "Could not create vertex shader!";
}

gl.shaderSource(vertexShader, vertexShaderSource);
gl.compileShader(vertexShader);

const fragmentShaderSource = `
  precision mediump float;

  void main() {
    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
  }
`;

const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);

if (!fragmentShader) {
  throw "Could not create fragment shader!";
}

gl.shaderSource(fragmentShader, fragmentShaderSource);
gl.compileShader(fragmentShader);

const program = gl.createProgram();

if (!program) {
  throw "Could not create the program!";
}

gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);

gl.linkProgram(program);

gl.useProgram(program);

gl.clearColor(0.0, 0.0, 0.0, 1.0);
gl.clear(gl.COLOR_BUFFER_BIT);

gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
gl.drawArrays(gl.POINTS, 0, vertices.length / 2);


--------------------------------------------------------------------------------
Render a line
--------------------------------------------------------------------------------

const canvas = document.createElement("canvas");
canvas.width = 512;
canvas.height = 512;

document.body.appendChild(canvas);

const gl = canvas.getContext("webgl2");

if (!gl) {
  throw "WebGL2 not supported!";
}

const vertices = [
  -0.5, -0.5,
   0.5,  0.5
];
const vertexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

const vertexShaderSource = `
  attribute vec2 a_position;

  void main() {
    gl_Position = vec4(a_position, 0.0, 1.0);
  }
`;

const vertexShader = gl.createShader(gl.VERTEX_SHADER);

if (!vertexShader) {
  throw "Could not create vertex shader!";
}

gl.shaderSource(vertexShader, vertexShaderSource);
gl.compileShader(vertexShader);

const fragmentShaderSource = `
  precision mediump float;

  void main() {
    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
  }
`;

const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);

if (!fragmentShader) {
  throw "Could not create fragment shader!";
}

gl.shaderSource(fragmentShader, fragmentShaderSource);
gl.compileShader(fragmentShader);

const program = gl.createProgram();

if (!program) {
  throw "Could not create program";
}

gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);
gl.useProgram(program);

gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);

const a_position = gl.getAttribLocation(program, "a_position");
gl.enableVertexAttribArray(a_position);
gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);

gl.clearColor(0.0, 0.0, 0.0, 1.0);
gl.clear(gl.COLOR_BUFFER_BIT);

gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
gl.drawArrays(gl.LINES, 0, vertices.length / 2);


--------------------------------------------------------------------------------
Render a triangle
--------------------------------------------------------------------------------

Pseudocode
Create and configure the canvas
Get the webgl2 context
Create a vertex buffer with 3 vertices
Create and compile a vertex shader with a_position
Create and compile a fragment shader that colors everything red
Create, link and use a program with the vertex and fragment shader
Configure a_position
Set the clear color to black
Clear the color buffer bit
Render the triangle with gl.drawArrays and gl.TRIANGLES

function app() {
  const canvas = document.createElement("canvas");
  canvas.width = 512;
  canvas.height = 512;
  document.body.appendChild(canvas);

  const gl = canvas.getContext("webgl2");

  if (!gl) {
    throw "WebGL2 is not supported!";
  }

  const vertices = [
    -0.5, -0.5,
     0.5, -0.5,
     0.0,  0.5
];
  const vertexBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

  const vertexShaderSource = `
  attribute vec2 a_position;

  void main() {
    gl_Position = vec4(a_position, 0.0, 1.0);
  }
  `;
  const vertexShader = gl.createShader(gl.VERTEX_SHADER);
  if (!vertexShader) {
    throw "Could not create the vertex shader!";
  }
  gl.shaderSource(vertexShader, vertexShaderSource);
  gl.compileShader(vertexShader);

  const fragmentShaderSource = `
  precision mediump float;

  void main() {
    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
  }
  `;
  const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
  if (!fragmentShader) {
    throw "Could not create the fragment shader!";
  }
  gl.shaderSource(fragmentShader, fragmentShaderSource);
  gl.compileShader(fragmentShader);

  const program = gl.createProgram();
  if (!program) {
    throw "Could not create the program!"
  }
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  gl.useProgram(program);

  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
  const a_position = gl.getAttribLocation(program, "a_position");
  gl.enableVertexAttribArray(a_position);
  gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);

  gl.clearColor(0.0, 0.0, 0.0, 1.0);
  gl.clear(gl.COLOR_BUFFER_BIT);

  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
  gl.drawArrays(gl.TRIANGLES, 0, vertices.length / 2);
}

app();
Render a rectangle
Code

/*
Use gl.TRIANGLE_STRIP to render a rectangle.

Pseudocode
- Init a canvas with a webgl2 context
- Init an array buffer with the rectangle vertices
- Init a vertex shader with a_position
- Init a fragment shader that colors everything red
- Init a program with the vertex and fragment shaders
- Init attribute a_position
- Set the clear color to black
- Clear the color buffer bit
- Draw the triangle with drawArrays and TRIANGLE_STRIP
 */

function app(): void
{
  const canvas: HTMLCanvasElement = document.createElement("canvas");
  canvas.width = 512;
  canvas.height = 512;
  document.body.appendChild(canvas);

  const gl: WebGL2RenderingContext|null = canvas.getContext("webgl2");

  if (!gl) {
    throw "WebGL2 is not supported!";
  }

  const vertices: number[] = [
    -0.5, -0.5,
     0.5, -0.5,
    -0.5,  0.5,
     0.5,  0.5
  ];
  const vertexBuffer: WebGLBuffer|null = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

  const vertexShaderSource: string = `attribute vec2 a_position;

  void main() {
    gl_Position = vec4(a_position, 0.0, 1.0);
  }`;
  const vertexShader: WebGLShader|null = gl.createShader(gl.VERTEX_SHADER);
  if (!vertexShader) {
    throw "Failed to create the vertex shader!";
  }
  gl.shaderSource(vertexShader, vertexShaderSource);
  gl.compileShader(vertexShader);

  const fragmentShaderSource: string = `precision mediump float;

  void main() {
    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
  }`;
  const fragmentShader: WebGLShader|null = gl.createShader(gl.FRAGMENT_SHADER);
  if (!fragmentShader) {
    throw "Failed to create the fragment shader!";
  }
  gl.shaderSource(fragmentShader, fragmentShaderSource);
  gl.compileShader(fragmentShader);

  const program: WebGLProgram|null = gl.createProgram();
  if (!program) {
    throw "Failed to create the program!";
  }
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  gl.useProgram(program);

  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
  const a_position: number = gl.getAttribLocation(program, "a_position");
  gl.enableVertexAttribArray(a_position);
  gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);

  gl.clearColor(0.0, 0.0, 0.0, 1.0);
  gl.clear(gl.COLOR_BUFFER_BIT);

  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, vertices.length / 2);
}

app();
Clever vertex indexing for rectangles
Go in a circle CCV:

Render a circle
Notes:
It is more effective to draw the circle with the TRIANGLE_FAN method than to use a vertex and element buffer.
Use the parametric circle function to generate the circle vertices.

/*
Pseudocode:
- Configure a canvas with a webgl2 context
- Use the parametric circle function to generate circle vertices with sectors
- Create an array buffer with circle vertices
- Create a vertex shader with a_position
- Create a fragment shader that colors everything red
- Create a program with the vertex and fragment shaders
- Configure a_position
- Set the clear color to black
- Clear the color buffer bit
- Render the circle with drawArrays and gl.TRIANGLE_FAN
 */

function circleVertices(r: number, sectors: number): number[]
{
  const vertices: number[] = [0.0, 0.0];

  const dAngle: number = 2.0*Math.PI / sectors;

  for (let i = 0; i < sectors + 1; i++)
  {
    const angle: number = i*dAngle;
    vertices.push(r*Math.cos(angle), r*Math.sin(angle));
  }

  return vertices;
}

function app(): void
{
  const canvas: HTMLCanvasElement = document.createElement("canvas");
  canvas.width = 512;
  canvas.height = 512;
  document.body.appendChild(canvas);

  const gl: WebGL2RenderingContext|null = canvas.getContext("webgl2");

  if (!gl) {
    throw "WebGL2 is not supported!";
  }

  const r: number = 0.3;
  const sectors: number = 12;
  const vertices: number[] = circleVertices(r, sectors);
  const vertexBuffer: WebGLBuffer|null = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

  const vertexShaderSource: string = `attribute vec2 a_position;
  
  void main() {
    gl_Position = vec4(a_position, 0.0, 1.0);
  }`;
  const vertexShader: WebGLShader|null = gl.createShader(gl.VERTEX_SHADER);
  if (!vertexShader) {
    throw "Failed to create the vertex shader!";
  }
  gl.shaderSource(vertexShader, vertexShaderSource);
  gl.compileShader(vertexShader);

  const fragmentShaderSource: string = `precision mediump float;
  
  void main() {
    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
  }`;
  const fragmentShader: WebGLShader|null = gl.createShader(gl.FRAGMENT_SHADER);
  if (!fragmentShader) {
    throw "Failed to create the fragment shader!";
  }
  gl.shaderSource(fragmentShader, fragmentShaderSource);
  gl.compileShader(fragmentShader);

  const program: WebGLProgram|null = gl.createProgram();
  if (!program) {
    throw "Failed to create the program!";
  }
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  gl.useProgram(program);

  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
  const a_position: number = gl.getAttribLocation(program, "a_position");
  gl.enableVertexAttribArray(a_position);
  gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);

  gl.clearColor(0.0, 0.0, 0.0, 1.0);
  gl.clear(gl.COLOR_BUFFER_BIT);

  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
  gl.drawArrays(gl.TRIANGLE_FAN, 0, sectors + 2);
}

app();
Render a cube

/*
Pseudocode
- Init a canvas with the webgl2 context
- Init cube vertices
- Rotate cube vertices for a better preview
- Init an array buffer with the cube vertices
- Init an element array buffer with the indices of the cube
- Init an array buffer with random colors per vertex
- Init a vertex shader with a_position, a_color and v_color
- Init a fragment shader with v_color
- Init a program with the vertex and fragment shaders
- Init a_position
- Init a_color
- Enable the depth test for correct depth rendering
- Set the clear color to black
- Clear the color buffer bit
- Render the cube with drawElements and gl.TRIANGLES
 */

import {Matrix4x4, multiplyMatrix4x4Vector3, rotationX, rotationY, Vector3} from "./math.ts";

function rotateVertices(vertices: number[]): number[]
{
  const xRotation: Matrix4x4 = rotationX(2.0*Math.PI * 0.025);
  const yRotation: Matrix4x4 = rotationY(2.0*Math.PI * 0.05);

  const rotated: number[] = [];
  for (let i = 0; i < vertices.length; i += 3)
  {
    let v: Vector3 = [vertices[i], vertices[i+1], vertices[i+2]];
    v = multiplyMatrix4x4Vector3(xRotation, v);
    v = multiplyMatrix4x4Vector3(yRotation, v);
    rotated.push(...v);
  }

  return rotated;
}

function randomColors(count: number): number[]
{
  const colors: number[] = [];

  for (let i = 0; i < count; i++)
  {
    colors.push(Math.random());
    colors.push(Math.random());
    colors.push(Math.random());
  }

  return colors;
}

function app(): void
{
  const canvas: HTMLCanvasElement = document.createElement("canvas");
  canvas.width = 512;
  canvas.height = 512;
  document.body.appendChild(canvas);

  const gl: WebGL2RenderingContext|null = canvas.getContext("webgl2");

  if (!gl) {
    throw "WebGL2 is not supported!";
  }

  let vertices: number[] = [
    -0.5, -0.5,  0.5,
     0.5, -0.5,  0.5,
     0.5,  0.5,  0.5,
    -0.5,  0.5,  0.5,
     0.5, -0.5, -0.5,
    -0.5, -0.5, -0.5,
    -0.5,  0.5, -0.5,
     0.5,  0.5, -0.5
  ];
  vertices = rotateVertices(vertices);
  const vertexBuffer: WebGLBuffer|null = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

  const indices: number[] = [
    0, 1, 2,
    2, 3, 0,
    3, 2, 7,
    7, 6, 3,
    6, 7, 4,
    4, 5, 6,
    5, 4, 1,
    1, 0, 5,
    1, 4, 7,
    7, 2, 1,
    5, 0, 3,
    3, 6, 5
  ];
  const indexBuffer: WebGLBuffer|null = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint8Array(indices), gl.STATIC_DRAW);

  const colors: number[] = randomColors(indices.length);
  const colorBuffer: WebGLBuffer|null = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);

  const vertexShaderSource: string = `attribute vec3 a_position;
  attribute vec3 a_color;
  varying vec3 v_color;

  void main() {
    gl_Position = vec4(a_position, 1.0);
    v_color = a_color;
  }`;
  const vertexShader: WebGLShader|null = gl.createShader(gl.VERTEX_SHADER);
  if (!vertexShader) {
    throw "Failed to create the vertex shader!";
  }
  gl.shaderSource(vertexShader, vertexShaderSource);
  gl.compileShader(vertexShader);

  const fragmentShaderSource: string = `precision mediump float;
  varying vec3 v_color;

  void main() {
    gl_FragColor = vec4(v_color, 1.0);
  }`;
  const fragmentShader: WebGLShader|null = gl.createShader(gl.FRAGMENT_SHADER);
  if (!fragmentShader) {
    throw "Failed to create the fragment shader!";
  }
  gl.shaderSource(fragmentShader, fragmentShaderSource);
  gl.compileShader(fragmentShader);

  const program: WebGLProgram|null = gl.createProgram();
  if (!program) {
    throw "Failed to create the program!";
  }
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  gl.useProgram(program);

  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
  const a_position: number = gl.getAttribLocation(program, "a_position");
  gl.enableVertexAttribArray(a_position);
  gl.vertexAttribPointer(a_position, 3, gl.FLOAT, false, 0, 0);

  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
  const a_color: number = gl.getAttribLocation(program, "a_color");
  gl.enableVertexAttribArray(a_color);
  gl.vertexAttribPointer(a_color, 3, gl.FLOAT, false, 0, 0);

  gl.enable(gl.DEPTH_TEST);

  gl.clearColor(0.0, 0.0, 0.0, 1.0);
  gl.clear(gl.COLOR_BUFFER_BIT);

  gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_BYTE, 0);
}

app();
Render a cone
Visual representation of the algorithm:

/*
Pseudocode
- Create canvas
- Get webgl2 context
- Create vertex buffer with vertices calculated with cos(angle), sin(angle)
- Create a random color buffer
- Create an index buffer that goes bottom 2 to end and then top 2 to end
- Create vertex shader with a_position, a_color and v_color
- Create fragment shader with v_color
- Create a program with the vertex and fragment shaders
- Configure a_position
- Configure a_color
- Set the clear color to black
- Clear the color buffer bit
- Set the active buffer to the vertex buffer
- Render using drawElements for the base
- Render using drawElements for the sides
*/

import { Matrix4x4, Vector3, multiplyMatrix4x4Vector3, rotationX } from "./math";

function coneVertices(segments: number): number[] {
  const vertices: number[] = [];

  // Data
  const radius: number = 0.3;
  const height: number = 0.5;

  // Base
  vertices.push(0.0, 0.0, 0.0);

  // Top
  vertices.push(0.0, height, 0.0);

  // Circle
  for (let i = 0; i <= segments; i++) {
    const angle: number = 2.0*Math.PI / segments * i;
    vertices.push(radius * Math.cos(angle), 0.0, radius * Math.sin(angle));
  }

  return vertices;
}

function coneIndices(segments: number): number[] {
  const indices: number[] = [];

  indices.push(0);
  for (let i = 2; i <= segments + 2; i++) {
    indices.push(i);
  }

  indices.push(1);
  for (let i = 2; i <= segments + 2; i++) {
    indices.push(i);
  }

  return indices;
}

function randomColors(count: number): number[] {
  const colors: number[] = [];

  for (let i = 0; i < count; i++) {
    colors.push(Math.random(), Math.random(), Math.random());
  }

  return colors;
}

function rotateVertices(vertices: number[]): number[] {
  const rotX: Matrix4x4 = rotationX(Math.PI*0.1);

  const rotated: number[] = [];
  for (let i = 0; i < vertices.length; i += 3) {
    let v: Vector3 = [vertices[i], vertices[i+1], vertices[i+2]];
    v = multiplyMatrix4x4Vector3(rotX, v);
    rotated.push(...v);
  }

  return rotated;
}

function app(): undefined {
  const canvas: HTMLCanvasElement = document.createElement("canvas");
  canvas.width = 512;
  canvas.height = 512;
  document.body.appendChild(canvas);

  const gl: WebGL2RenderingContext|null = canvas.getContext("webgl2");

  if (!gl) {
    throw "WebGL2 is not supported";
  }

  const coneSegments: number = 12;

  let vertices: number[] = coneVertices(coneSegments);
  vertices = rotateVertices(vertices);
  const vertexBuffer: WebGLBuffer|null = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
  gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(vertices),gl.STATIC_DRAW);

  const colors: number[] = randomColors(vertices.length / 3);
  const colorBuffer: WebGLBuffer|null = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);

  const indices: number[] = coneIndices(coneSegments);
  const indexBuffer: WebGLBuffer|null = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,new Uint8Array(indices),gl.STATIC_DRAW);

  const vertexShaderSource: string = `
    attribute vec3 a_position;
    attribute vec3 a_color;
    varying vec3 v_color;

    void main() {
      gl_Position = vec4(a_position, 1.0);
      v_color = a_color;
    }
  `;
  const vertexShader: WebGLShader|null = gl.createShader(gl.VERTEX_SHADER);
  if (!vertexShader) {
    throw "Failed to create shader";
  }
  gl.shaderSource(vertexShader, vertexShaderSource);
  gl.compileShader(vertexShader);

  const fragmentShaderSource: string = `
    precision mediump float;

    varying vec3 v_color;

    void main() {
      gl_FragColor = vec4(v_color, 1.0);
    }
  `;
  const fragmentShader: WebGLShader|null = gl.createShader(gl.FRAGMENT_SHADER);
  if (!fragmentShader) {
    throw "Failed to create shader";
  }
  gl.shaderSource(fragmentShader, fragmentShaderSource);
  gl.compileShader(fragmentShader);

  const program: WebGLProgram|null = gl.createProgram();
  if (!program) {
    throw "Failed to create program";
  }
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  gl.useProgram(program);

  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
  const a_position: number = gl.getAttribLocation(program, "a_position");
  gl.enableVertexAttribArray(a_position);
  gl.vertexAttribPointer(a_position, 3, gl.FLOAT, false, 0, 0);

  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
  const a_color: number = gl.getAttribLocation(program, "a_color");
  gl.enableVertexAttribArray(a_color);
  gl.vertexAttribPointer(a_color, 3, gl.FLOAT, false, 0, 0);

  gl.enable(gl.DEPTH_TEST);
  gl.clearColor(0.0, 0.0, 0.0, 1.0);
  gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
  gl.drawElements(gl.TRIANGLE_FAN, indices.length / 2, gl.UNSIGNED_BYTE, 0);
  gl.drawElements(gl.TRIANGLE_FAN, indices.length / 2, gl.UNSIGNED_BYTE, indices.length / 2);
}

app();
Render a cylinder
Pseudocode
Create and configure canvas
Get the webgl2 context
Create a vertex buffer
Create a random color buffer
Create an index buffer
Create a vertex shader with a_position, a_color, v_color
Create a fragment shader with v_color
Create, link and use a program with the vertex and fragment shaders
Configure a_position
Configure a_color
Set the clear color to black
Clear the color
Draw the cylinder base with gl.drawElements and gl.TRIAGNLE_FAN
Draw the cylinder top with gl.drawElements and gl.TRIANGLE_FAN
Draw the cylinder sides with gl.drawElements and gl.TRIANGLE_STRIP

Visual representation of the algorithm to generate the vertices and indices:


import { Matrix4x4, Vector3, multiplyMatrix4x4Vector3, rotationX } from "./math";

function rotateVertices(vertices: number[]): number[] {
  const rotX: Matrix4x4 = rotationX(Math.PI*0.1);

  const rotated: number[] = [];
  for (let i = 0; i < vertices.length; i += 3) {
    let v: Vector3 = [vertices[i], vertices[i+1], vertices[i+2]];
    v = multiplyMatrix4x4Vector3(rotX, v);
    rotated.push(...v);
  }

  return rotated;
}

function cylinderVertices(segments: number): number[] {
  const height: number = 0.5;
  const radius: number = 0.25;

  const vertices: number[] = [];

  // Bottom
  for (let  i = 0;  i < segments;  i++) {
    const angle: number = 2.0*Math.PI / segments * i;
    vertices.push(radius*Math.cos(angle), 0.0, radius*Math.sin(angle));
  }

  // Top
  for (let  i = 0;  i < segments;  i++) {
    const angle: number = 2.0*Math.PI / segments * i;
    vertices.push(radius*Math.cos(angle), height, radius*Math.sin(angle));
  }

  // Center vertices
  vertices.push(0.0, 0.0, 0.0);
  vertices.push(0.0, height, 0.0);

  return vertices;
}

function cylinderIndices(vertices: number[]): number[] {
  const count: number = vertices.length / 3;

  const indices: number[] = [];

  // Bottom
  indices.push(count-2);
  for (let i = 0; i < (count-2) / 2; i++) {
    indices.push(i);
  }
  indices.push(0);

  // Top
  indices.push(count-1);
  for (let i = (count-2)/2; i < count-2; i++) {
    indices.push(i);
  }
  indices.push((count-2)/2);

  // Sides
  for (let i = 0; i < (count-2)/2; i++) {
    indices.push(i);
    indices.push((count-2)/2 + (i));
  }
  indices.push(0);
  indices.push((count-2)/2);

  return indices;
}

function randomColors(count: number): number[] {
  const colors: number[] = [];

  for (let i = 0; i < count; i++) {
    colors.push(Math.random(), Math.random(), Math.random());
  }

  return colors;
}

function app(): undefined {
  const canvas: HTMLCanvasElement = document.createElement("canvas");
  canvas.width = 512;
  canvas.height = 512;
  document.body.appendChild(canvas);

  const gl: WebGL2RenderingContext|null = canvas.getContext("webgl2");

  if (!gl) {
    throw "WebGL2 is not supported";
  }

  const segments: number = 12;
  let vertices: number[] = cylinderVertices(segments);
  vertices = rotateVertices(vertices);
  const vertexBuffer: WebGLBuffer|null = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

  const colors: number[] = randomColors(vertices.length / 3);
  const colorBuffer: WebGLBuffer|null = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);

  const indices: number[] = cylinderIndices(vertices);
  const indexBuffer: WebGLBuffer|null = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint8Array(indices), gl.STATIC_DRAW);

  const vertexShaderSource: string = `
  attribute vec3 a_position;
  attribute vec3 a_color;
  varying vec3 v_color;

  void main() {
    gl_Position = vec4(a_position, 1.0);
    v_color = a_color;
  }
  `;
  const vertexShader: WebGLShader|null = gl.createShader(gl.VERTEX_SHADER);
  if (!vertexShader) {
    throw "Failed to create shader";
  }
  gl.shaderSource(vertexShader, vertexShaderSource);
  gl.compileShader(vertexShader);

  const fragmentShaderSource: string = `
  precision mediump float;

  varying vec3 v_color;

  void main() {
    gl_FragColor = vec4(v_color, 1.0);
  }
  `;
  const fragmentShader: WebGLShader|null = gl.createShader(gl.FRAGMENT_SHADER);
  if (!fragmentShader) {
    throw "Failed to create shader";
  }
  gl.shaderSource(fragmentShader, fragmentShaderSource);
  gl.compileShader(fragmentShader);

  const program: WebGLProgram|null = gl.createProgram();
  if (!program) {
    throw "Failed to create program";
  }
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  gl.useProgram(program);

  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
  const a_position: number = gl.getAttribLocation(program, "a_position");
  gl.enableVertexAttribArray(a_position);
  gl.vertexAttribPointer(a_position, 3, gl.FLOAT, false, 0, 0);

  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
  const a_color: number = gl.getAttribLocation(program, "a_color");
  gl.enableVertexAttribArray(a_color);
  gl.vertexAttribPointer(a_color, 3, gl.FLOAT, false, 0, 0);

  gl.enable(gl.DEPTH_TEST);
  gl.clearColor(0.0, 0.0, 0.0, 1.0);
  gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
  gl.drawElements(gl.TRIANGLE_FAN, segments+2, gl.UNSIGNED_BYTE, 0);
  gl.drawElements(gl.TRIANGLE_FAN, segments+2, gl.UNSIGNED_BYTE, segments+2);
  gl.drawElements(gl.TRIANGLE_STRIP, 2*segments + 2, gl.UNSIGNED_BYTE, 2*(segments+2));
}

app();
Render a sphere
Optimal sphere rendering approach
Pseudocode for generating sphere vertices and element buffers:
Use the parametric sphere function to generate the vertices. Take a look below to find what the result will be.
Use an unwrapped sphere to figure out how to order the indices. The sphere should be rendered as a TRIANGLE_FAN at the top and at the bottom. The middle should be TRIANGLE_STRIPs for each strip.
The rest is a simple WebGL element array buffer rendering program.





function sphereVertices(r: number, stacks: number, sectors: number): number[]
{
  const vertices: number[] = [];
  const dTheta: number = Math.PI / stacks;
  const dPhi: number = 2.0*Math.PI / sectors;

  for (let i = 0; i < stacks + 1; i++)
  {
    const theta: number = i * dTheta;

    for (let j = 0; j < sectors; j++)
    {
      const phi: number = j * dPhi;

      const x: number = r * Math.sin(theta) * Math.cos(phi);
      const y: number = r * Math.sin(theta) * Math.sin(phi);
      const z: number = r * Math.cos(theta);

      vertices.push(x, y, z);
    }
  }

  return vertices;
}
Sphere vertices generator
Pseudocode
Look at the sphere from the side, it will have rings from -Math.PI to Math.PI as many as many segments there are
Look at the sphere from the top, it will have a circular ring stripe like a cylinder, but it gets smaller as it goes the top or the bottom
For each angle in -Math.PI to Math.PI in a Math.PI/segments step calculate the current and next y position of the ring and calculate the current and next radius of the ring. The y position is radius * Math.sin(angle) and the radius is radius * Math.cos(angle).
Create a ring of points by using the vertices for the triangles.

function sphereVertices(): number[] {
  const segments: number = 16;
  const radius: number = 0.5;

  const vertices: number[] = [];

  let angle: number = -Math.PI/2;
  for (let i = 0; i < segments; i++) {
    const angle1: number = angle + Math.PI / segments;
    const r: number = radius * Math.cos(angle);
    const r1: number = radius * Math.cos(angle1);
    const height: number = radius * Math.sin(angle);
    const height1: number = radius * Math.sin(angle1);

    for (let j = 0; j < segments; j++) {
      const point1Angle = j * 2.0 * Math.PI / segments;
      const point2Angle = ((j + 1) % segments) * 2.0 * Math.PI / segments;

      vertices.push(
        r*Math.sin(point1Angle), height, r*Math.cos(point1Angle),
        r*Math.sin(point2Angle), height, r*Math.cos(point2Angle),
        r1*Math.sin(point1Angle), height1, r1*Math.cos(point1Angle),
        r1*Math.sin(point1Angle), height1, r1*Math.cos(point1Angle),
        r*Math.sin(point2Angle), height, r*Math.cos(point2Angle),
        r1*Math.sin(point2Angle), height1, r1*Math.cos(point2Angle)
      );
    }

    angle += Math.PI / segments;
  }

  return vertices;
}
Depth testing
Enable depth testing
gl.enable(gl.DEPTH_TEST);
Clear the color buffer bit and the depth buffer bit
gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
Textures
Texture registers
There are at least 32 texture registers.
gl.uniform1i(x, 1)
gl.uniform1i(x, 1) is used to initialize the uniform at location x as 1 integer with the value "1".

Use gl.uniform1i(u_texture, 0) to set the value of uniform sampler2D u_texture.
Texture code
const texture = await new Promise((resolve, reject) => {
const image = new Image();

image.onload = () => {
const texture = gl.createTexture();
gl.activeTexture(gl.TEXTURE0);
gl.bindTexture(gl.TEXTURE_2D, texture);

gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
  
resolve(texture);
};
  
image.onerror = () => {
reject("Could not load texture!");
};

image.src = "data:image/jpeg;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAIAAABLbSncAAAA2ElEQVR4nADIADf/AzTxP7UyDiuAMXWgTaGBpBHtI9OMDvstRQHkC0qgh7qTtQDLFNzFNRwZ4UVV8gokj+gA+7rcmO4lQ4yeN+PE5Ci33UAupt8yMEHOAVT1QQRho2IkuhXTNisF9RKAvEPMXWEqTABNerqoQxJT3cIWPna4/iFwrB5DQpXPPCcETgTFUbGFQBgeHsyf4mXDLem08efx/PLEAOnYDjYVA+KhFGYsZI5ZNPTbZfscwNTSAwDgxwwhWiwEKNZCEQON+gfVR8JJkvOj9R0BAAD//2gqW45hJV3CAAAAAElFTkSuQmCC";
});
  
const u_texture = gl.getUniformLocation(program, "u_texture");
gl.uniform1i(u_texture, 0);
Rectangle with texture code
Pseudocode:
Create and configure a canvas
Get the webgl2 context from the canvas
Create the vertex buffer with 4 vertices
Create the uv buffer with 4 vertices
Create a vertex shader with a_position, a_uv, v_uv
Create a fragment shader with v_uv, u_texture
Create a program with the vertex and fragment shaders
Configure a_position
Configure a_uv
Load, create and configure the texture to TEXTURE0
Configure u_texture to slot 0
Set clear color to black
Clear the color
Bind the vertex buffer
Render the rectangle with gl.drawArrays and gl.TRIANGLE_STRIP

async function app() {
  const canvas = document.createElement("canvas");
  canvas.width = 512;
  canvas.height = 512;
  document.body.appendChild(canvas);

  const gl = canvas.getContext("webgl2");

  if (!gl) {
    throw "WebGL2 is not supported!";
  }

  const vertices = [
     0.5, -0.5,
     0.5,  0.5,
    -0.5, -0.5,
    -0.5,  0.5
  ];
  const vertexBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

  const uvs = [
    1.0, 0.0,
    1.0, 1.0,
    0.0, 0.0,
    0.0, 1.0
  ];
  const uvBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, uvBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(uvs), gl.STATIC_DRAW);

  const vertexShaderSource =
  `attribute vec2 a_position;
  attribute vec2 a_uv;
  varying vec2 v_uv;

  void main() {
    gl_Position = vec4(a_position, 0.0, 1.0);
    v_uv = a_uv;
  }`;
  const vertexShader = gl.createShader(gl.VERTEX_SHADER);
  if (!vertexShader) {
    throw "Could not create vertex shader!";
  }
  gl.shaderSource(vertexShader, vertexShaderSource);
  gl.compileShader(vertexShader);
  if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
    const log = gl.getShaderInfoLog(vertexShader);
    console.error(log);
  }

  const fragmentShaderSource =
  `precision mediump float;
  
  uniform sampler2D u_texture;
  varying vec2 v_uv;

  void main() {
    gl_FragColor = texture2D(u_texture, v_uv);
  }`;
  const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
  if (!fragmentShader) {
    throw "Could not create fragment shader!";
  }
  gl.shaderSource(fragmentShader, fragmentShaderSource);
  gl.compileShader(fragmentShader);
  if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
    const log = gl.getShaderInfoLog(fragmentShader);
    console.error(log);
  }

  const program = gl.createProgram();
  if (!program) {
    throw ""
  }
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  gl.useProgram(program);

  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
  const a_position = gl.getAttribLocation(program, "a_position");
  gl.enableVertexAttribArray(a_position);
  gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);

  gl.bindBuffer(gl.ARRAY_BUFFER, uvBuffer);
  const a_uv = gl.getAttribLocation(program, "a_uv");
  gl.enableVertexAttribArray(a_uv);
  gl.vertexAttribPointer(a_uv, 2, gl.FLOAT, false, 0, 0);

  await new Promise((resolve, reject) => {
    const image = new Image();

    image.onload = () => {
      const texture = gl.createTexture();
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, texture);

      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

      resolve(texture);
    };

    image.onerror = () => {
      reject("Could not load the texture image!");
    };

    image.src = "data:image/jpeg;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAIAAABLbSncAAAA2ElEQVR4nADIADf/AzTxP7UyDiuAMXWgTaGBpBHtI9OMDvstRQHkC0qgh7qTtQDLFNzFNRwZ4UVV8gokj+gA+7rcmO4lQ4yeN+PE5Ci33UAupt8yMEHOAVT1QQRho2IkuhXTNisF9RKAvEPMXWEqTABNerqoQxJT3cIWPna4/iFwrB5DQpXPPCcETgTFUbGFQBgeHsyf4mXDLem08efx/PLEAOnYDjYVA+KhFGYsZI5ZNPTbZfscwNTSAwDgxwwhWiwEKNZCEQON+gfVR8JJkvOj9R0BAAD//2gqW45hJV3CAAAAAElFTkSuQmCC";
  });

  const u_texture = gl.getUniformLocation(program, "u_texture");
  gl.uniform1i(u_texture, 0);

  gl.clearColor(0.0, 0.0, 0.0, 1.0);
  gl.clear(gl.COLOR_BUFFER_BIT);

  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, vertices.length / 2);
}

Pixel loading order
  WebGL expects texture pixels to be loaded bottom left to top right.
  Normal image pixels in the browser are ordered top left to bottom right.
  To fix this, we use gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
Learning guide:
Module 1: Introduction to WebGL
Overview of WebGL and its applications
Understanding the graphics pipeline
Setting up a development environment
Basic drawing with WebGL: points, lines, and triangles
Shaders: Vertex and Fragment shaders
Module 2: Working with 2D Graphics
Rendering 2D shapes: squares, circles, polygons
Introduction to transformations: translation, rotation, scaling
Texturing: Applying images to 2D shapes
Basic animation techniques
Module 3: 3D Graphics Fundamentals
Introduction to 3D space: coordinates, vectors, matrices
Creating 3D primitives: cubes, spheres, cylinders
Lighting in WebGL: Ambient, Diffuse, Specular
Introduction to perspective projection
Module 4: Advanced 3D Techniques
Texture mapping on 3D objects
Implementing shadows: shadow mapping
Working with advanced lighting models: Phong shading, Blinn-Phong shading
Introduction to shaders in detail: Uniforms, Attributes, Varyings
Module 5: WebGL Frameworks and Libraries
Overview of popular WebGL libraries: Three.js, Babylon.js
Setting up and using a WebGL framework
Exploring advanced features provided by frameworks
Comparing different libraries and choosing the right one for the project
Module 6: WebGL Optimization and Performance
Understanding performance bottlenecks in WebGL
Techniques for optimizing rendering performance
GPU optimization strategies
Asset optimization for faster loading times
Module 7: WebGL and Interaction
Handling user input: mouse events, keyboard events
Implementing basic interactivity: object picking, object highlighting
Introduction to WebGL-based UI components
Module 8: WebGL and Integration
Integrating WebGL with HTML5 Canvas
Integrating WebGL with other web technologies: CSS, SVG
WebGL and server-side technologies: WebSockets, WebRTC
Module 9: WebGL and Virtual Reality (VR)
Introduction to WebVR and its APIs
Creating VR experiences with WebGL
Working with VR devices: Oculus Rift, HTC Vive, Google Cardboard
Module 10: Final Project
Students work on a final project applying all concepts learned throughout the course
Guidance and feedback provided by instructors
Presentation of final projects to the class
Additional Resources and Assignments:
Weekly assignments to reinforce learning
Recommended readings, tutorials, and online resources
Hands-on coding exercises and projects
Optional exploration of advanced topics such as WebGL2, compute shaders, and more.
